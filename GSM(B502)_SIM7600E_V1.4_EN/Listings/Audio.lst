C51 COMPILER V9.57.0.0   AUDIO                                                             08/04/2022 14:16:59 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE AUDIO
OBJECT MODULE PLACED IN .\Objects\Audio.obj
COMPILER INVOKED BY: D:\keil-c51\C51\BIN\C51.EXE UserSrc\Audio.c LARGE OPTIMIZE(8,SPEED) BROWSE NOINTPROMOTE INCDIR(.\Us
                    -erSrc;.\StcLib;.\UserSrc\ENG) DEBUG OBJECTEXTEND PRINT(.\Listings\Audio.lst) TABS(2) OBJECT(.\Objects\Audio.obj)

line level    source

   1          #include "config.h"
   2          #include "Driver.h"
   3          #include "Audio.h"
   4          #include "stdio.h"
   5          #include "GPIO.h"
   6          #include "UART.h"
   7          #include "SysStatus.h"
   8          
   9          #ifdef MP3_MODULE
              //bool Mp3Busy = true;
              Mp3CmdType Mp3Cmd=
              {
                0x7EFF,
                0x06,
                0x09,
                0x00,
                0x00,
                0x02,
                0xFF0F,
                0xEF,
              };
              
              void Mp3SendCmd(void)
              {
                u8 *pD = (u8 *)&Mp3Cmd;
                u8 i;
                Mp3Cmd.Chk = 0;
                for(i=1;i<7;i++)
                {
                  Mp3Cmd.Chk += pD[i];
                }
                Mp3Cmd.Chk = ~Mp3Cmd.Chk;
                Mp3Cmd.Chk++;
                printf("Mp3UartTx: ");
                for(i=0;i<sizeof(Mp3Cmd);i++)
                {
                  printf("%b02X ",pD[i]);
                }
                printf("\r\n");
                Uart4SendBuf(pD,sizeof(Mp3Cmd));
              }
              
              void MP3_SetMode(void)
              {
                Mp3Cmd.Len = 6;
                Mp3Cmd.Cmd = MP3_CMD_SETMODE;
                Mp3Cmd.Para1 = 0;
                Mp3Cmd.Para2 = 2;
                Mp3SendCmd();
              }
              void MP3_SetVolum(void)
              {
                Mp3Cmd.Len = 6;
                Mp3Cmd.Cmd = MP3_CMD_SETVOLUM;
C51 COMPILER V9.57.0.0   AUDIO                                                             08/04/2022 14:16:59 PAGE 2   

                Mp3Cmd.Para1 = 0;
                Mp3Cmd.Para2 = 30;
                Mp3SendCmd();
              }
              
              void MP3_StartPlay(u16 idx)
              {
              //  if(Mp3Busy)
              //  {
              //    return;
              //  }
                Mp3Cmd.Len = 6;
                Mp3Cmd.Cmd = MP3_CMD_PLAY;
                Mp3Cmd.Para1 = (idx>>8)&0xFF;
                Mp3Cmd.Para2 = idx&0xFF;
                PA_PWR_L;
                Mp3SendCmd();
              //  Mp3Busy = true;
              }
              
              void Mp3UartRx(u8 * buf)
              {
                u8 i;
                u16 Chk = 0;
                Mp3CmdType *pTmp = (Mp3CmdType*)buf;
                printf("Mp3UartRx:");
                for(i=0;i<pTmp->Len+4;i++)
                {
                  printf("%b02X ",buf[i]);
                }
                printf("\r\n");
                for(i=1;i<pTmp->Len+1;i++)
                {
                  Chk += buf[i];
                }
                Chk = ~Chk;
                Chk++;
                if((pTmp->St == 0x7EFF) && (pTmp->End == 0xEF) && (Chk == pTmp->Chk))
                {
                  switch(pTmp->Cmd)
                  {
                    case MP3_CMD_PWRON:
                      if(pTmp->Para2 != 2)
                      {
                        MP3_SetMode();
                      }
                      else
                      {
                        //Mp3Busy = false;
                        MP3_SetVolum();
                      }
                      break;
                    case MP3_CMD_RE_STOP:
                      if(((IdleTime > 0) && (IdleTime <= 3)) || ((SysStatus != SYS_TALK) && (SysStatus != SYS_CALL)))
                      {
                        PA_PWR_H;
                      }
                      //Mp3Busy = false;
                      break;
                    case MP3_CMD_RE_ERR:
                      PA_PWR_H;
                      //Mp3Busy = false;
C51 COMPILER V9.57.0.0   AUDIO                                                             08/04/2022 14:16:59 PAGE 3   

                      break;
                  }
                }
              }
              #elif defined PWM_AUDIO
 122          
 123          #include "spi.h"
 124          
 125          void SPI_config(void)
 126          {
 127   1        SPI_InitTypeDef   SPI_InitStructure;
 128   1        SPI_InitStructure.SPI_Module    = ENABLE;           //SPI启动    ENABLE, DISABLE
 129   1        SPI_InitStructure.SPI_SSIG      = DISABLE;          //片选位     ENABLE, DISABLE
 130   1        SPI_InitStructure.SPI_FirstBit  = SPI_MSB;          //移位方向   SPI_MSB, SPI_LSB
 131   1        SPI_InitStructure.SPI_Mode      = SPI_Mode_Master;    //主从选择   SPI_Mode_Master, SPI_Mode_Slave
 132   1        SPI_InitStructure.SPI_CPOL      = SPI_CPOL_Low;    //时钟相位   SPI_CPOL_High,   SPI_CPOL_Low
 133   1        SPI_InitStructure.SPI_CPHA      = SPI_CPHA_1Edge;   //数据边沿   SPI_CPHA_1Edge,  SPI_CPHA_2Edge
 134   1        SPI_InitStructure.SPI_Interrupt = ENABLE;       //中断允许   ENABLE,DISABLE
 135   1        SPI_InitStructure.SPI_Speed     = SPI_Speed_4;      //SPI速度    SPI_Speed_4, SPI_Speed_16, SPI_Speed_64, S
             -PI_Speed_128
 136   1        SPI_InitStructure.SPI_IoUse     = SPI_P54_P40_P41_P43; //IO口切换   SPI_P12_P13_P14_P15, SPI_P22_P23_P24_
             -P25, SPI_P54_P40_P41_P43, SPI_P35_P34_P33_P32
 137   1        SPI_Init(&SPI_InitStructure);
 138   1        
 139   1        SPI_FLASH_CS_DISEN;
 140   1      }
 141          
 142          #define PWMC (*(unsigned int volatile xdata *)0xfff0)
 143          #define PWMCKS (*(unsigned char volatile xdata *)0xfff2)
 144          #define PWM0T1 (*(unsigned int volatile xdata *)0xff00)
 145          #define PWM0T2 (*(unsigned int volatile xdata *)0xff02)
 146          #define PWM0CR (*(unsigned char volatile xdata *)0xff04)
 147          sfr PWMCR = 0xfe;
 148          #define PWM_CYCLE 0x00FF
 149          #define PWM_STOP() {PWMCR = 0;}
 150          #define PWM_START() {PWMCR = 0x80;}
 151          void PWM_config(void)
 152          {
 153   1        EAXSFR();
 154   1        PWMCKS = 0x00;
 155   1        PWMC = PWM_CYCLE;
 156   1        PWM0T1 = 0;
 157   1        PWM0T2 = (PWM_CYCLE/2);
 158   1        PWM0CR = 0x90;
 159   1        EAXRAM();
 160   1        PWM_STOP();
 161   1      }
 162          
 163          #define WAV_BUFLEN 1024
 164          uint8_t WavBuf[2][WAV_BUFLEN];
 165          static uint16_t PlyIdx = 0;
 166          static uint8_t Midx = 0;
 167          uint16_t WavBufLen[2] = {0,0};
 168          uint32_t WavFileAddr = 0;
 169          uint32_t WavFileLen = 0;
 170          uint32_t WavReadIdx = 0;
 171          bool WavNeedRead = false;
 172          bool AudioPlaying = false;
 173          
 174          //WavFileType WavFile[MP3_Last-1]=
 175          //{
 176          //{0,51170},
C51 COMPILER V9.57.0.0   AUDIO                                                             08/04/2022 14:16:59 PAGE 4   

 177          //{51170,77254},
 178          //{128424,133702},
 179          //{262126,72646},
 180          //{334772,42112},
 181          //{376884,51766},
 182          //{428650,64582},
 183          //{493232,67476},
 184          //{560708,56364},
 185          //{617072,210944},
 186          //};
 187          WavFileType WavFile[MP3_Last-1]=
 188          {
 189          #ifdef LANGUAGE_HB  
              {0,68012},
              {68012,53036},
              {121048,46124},
              {167172,57644},
              {224816,58796},
              {283612,50732},
              {334344,58796},
              {393140,55340},
              {448480,42668},
              {491148,192386},
              {683534,34604},
              {718138,36908},
              {755046,57644},
              {812690,24236},
              {836926,62252},
              {899178,73772},
              {972950,12842},
              #else
 208          {0,95338},
 209          {95338,52708},
 210          {148046,43512},
 211          {191558,61902},
 212          {253460,46856},
 213          {300316,49364},
 214          {349680,61066},
 215          {410746,42676},
 216          {453422,50200},
 217          {503622,192386},
 218          {696008,44348},
 219          {740356,33482},
 220          {773838,32646},
 221          {806484,59394},
 222          {865878,95338},
 223          {961216,12842},
 224          #endif
 225          };
 226          void WavReadTask(void)
 227          {
 228   1        uint8_t midx;
 229   1      //  uint16_t i,tmp;
 230   1        if(WavNeedRead)
 231   1        {
 232   2          WavNeedRead = false;
 233   2          midx = 1-Midx;
 234   2          if((WavFileLen == 0) || (WavReadIdx == WavFileLen))
 235   2          {
 236   3            MP3_Stop();
 237   3            return;
 238   3          }
C51 COMPILER V9.57.0.0   AUDIO                                                             08/04/2022 14:16:59 PAGE 5   

 239   2          if((WavFileLen-WavReadIdx) >  WAV_BUFLEN)
 240   2          {
 241   3            WavBufLen[midx] = WAV_BUFLEN;
 242   3            WavReadIdx += WAV_BUFLEN;
 243   3          }
 244   2          else
 245   2          {
 246   3            WavBufLen[midx] = WavFileLen-WavReadIdx;
 247   3            WavFileLen = 0;
 248   3            if(((IdleTime > 0) && (IdleTime <= 3)) || ((SysStatus != SYS_TALK) && (SysStatus != SYS_CALL)))
 249   3            {
 250   4              PA_PWR_H;
 251   4            }
 252   3            
 253   3          }
 254   2          SPI_Flash_Read(WavBuf[midx],WavFileAddr+WavReadIdx,WavBufLen[midx]);
 255   2      //    for(i=0;i<WavBufLen[midx];i++)
 256   2      //    {
 257   2      //      tmp = WavBuf[midx][i];
 258   2      //      WavBuf[midx][i] = (tmp*SysPara.TalkVolum*2)/5;
 259   2      //    }
 260   2        }
 261   1      }
 262          
 263          void PWMtask(void)
 264          {
 265   1        //uint16_t tmp;
 266   1        if(PlyIdx < WavBufLen[Midx])
 267   1        {
 268   2          EAXSFR();
 269   2      //    tmp = WavBuf[Midx][PlyIdx+1];
 270   2      //    tmp <<= 8;
 271   2      //    tmp |= WavBuf[Midx][PlyIdx];
 272   2      //    PlyIdx += 2;
 273   2      //    if(tmp < 0){PlyIdx += 2;return;}
 274   2          PWM0T2 = WavBuf[Midx][PlyIdx++];
 275   2          EAXRAM();
 276   2        }
 277   1        else
 278   1        {
 279   2          PlyIdx = 0;
 280   2          Midx = 1-Midx;
 281   2          WavNeedRead = true;
 282   2        }
 283   1      }
 284          
 285          void MP3_StartPlay(uint8_t idx)
 286          {
 287   1        if(!SysPara.ToneEn)
 288   1        {
 289   2          return;
 290   2        }
 291   1      //  PWM_STOP();
 292   1        Timer4_Stop();
 293   1        PA_PWR_L;
 294   1        delay(500);
 295   1        WavFileAddr = WavFile[idx-1].FileAddr;
 296   1        WavFileLen = WavFile[idx-1].FileLen;
 297   1        
 298   1        PlyIdx = 0;
 299   1        WavReadIdx = 0;
 300   1        WavBufLen[0] = 0;
C51 COMPILER V9.57.0.0   AUDIO                                                             08/04/2022 14:16:59 PAGE 6   

 301   1        WavBufLen[1] = 0;
 302   1        
 303   1        Midx = 1;
 304   1        WavNeedRead = true;
 305   1        WavReadTask();
 306   1        
 307   1        Midx = 0;
 308   1        WavNeedRead = true;
 309   1        WavReadTask();
 310   1        
 311   1        PWM_START();
 312   1        Timer4_Run();
 313   1        AudioPlaying = true;
 314   1      }
 315          void MP3_Stop(void)
 316          {
 317   1        if(((IdleTime > 0) && (IdleTime <= 3)) || ((SysStatus != SYS_TALK) && (SysStatus != SYS_CALL)))
 318   1        {
 319   2          PA_PWR_H;
 320   2        }
 321   1        AudioPlaying = false;
 322   1      //  PWM_STOP();
 323   1        Timer4_Stop();
 324   1      }
 325          #endif
 326          
 327          #ifdef KEY_BEEP
 328          
 329          code BeepFileType WavCode[] = {
 330          {3,{3,2,1}},//OK
 331          {5,{1,0,1,0,1}},//Err
 332          {7,{1,1,1,0,1,0,1}},//Unlock
 333          {3,{1,0,1}},//Call
 334          {1,{1,2}},//Key
 335          };
 336          
 337          u8 BeepPlyIdx = 0xFF;
 338          u8 PlyN = 0;
 339          u8 PwmTimer = 0;
 340          bit KeyBeepO = 0;
 341          void Beep_StartPlay(u8 idx)
 342          {
 343   1        switch(idx)
 344   1        {
 345   2          case MP3_InputRoom:
 346   2          case MP3_InputPsw:
 347   2          case MP3_Key:
 348   2            PlyN = 4;
 349   2            break;
 350   2          case MP3_SetOK:
 351   2            PlyN = 0;
 352   2            break;
 353   2          case MP3_Unlock:
 354   2            PlyN = 2;
 355   2            break;
 356   2          case MP3_RoomErr:
 357   2          case MP3_PwdErr:
 358   2          case MP3_CardErr:
 359   2          case MP3_Noresponse:
 360   2            PlyN = 1;
 361   2            break;
 362   2          case MP3_Huangup:
C51 COMPILER V9.57.0.0   AUDIO                                                             08/04/2022 14:16:59 PAGE 7   

 363   2          case MP3_Ring:
 364   2            PlyN = 3;
 365   2            break;
 366   2        }
 367   1        
 368   1        BeepPlyIdx = 0;
 369   1        PwmTimer = 99;
 370   1        KeyBeepTask();
 371   1        KeyBeepO = 1;
 372   1      }
 373          
 374          void KeyBeepTask(void)
 375          {
 376   1        if(BeepPlyIdx != 0xFF)
 377   1        {
 378   2          if(++PwmTimer == 100)
 379   2          {
 380   3            PwmTimer = 0;
 381   3            if(BeepPlyIdx >= WavCode[PlyN].Len)
 382   3            {
 383   4              BeepPlyIdx = 0xFF;
 384   4              KeyBeepO = 0;
 385   4              P62 = 0;
 386   4              return;
 387   4            }
 388   3            KeyBeepO = 1;
 389   3            BeepPlyIdx++;
 390   3          }
 391   2        }
 392   1      }
 393          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    968    ----
   CONSTANT SIZE    =     55    ----
   XDATA SIZE       =   2198      11
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
